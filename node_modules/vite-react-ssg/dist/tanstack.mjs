import { jsxs, Fragment, jsx } from 'react/jsx-runtime';
import { RouterProvider } from '@tanstack/react-router';
import { Meta, StartClient } from '@tanstack/start';
import { HelmetProvider } from 'react-helmet-async';
import { r as render, h as hydrate, d as documentReady } from './shared/vite-react-ssg.BxjO14Et.mjs';
export { C as ClientOnly, H as Head } from './shared/vite-react-ssg.BxjO14Et.mjs';
import { j as joinUrlSegments, w as withLeadingSlash, s as stripBase } from './shared/vite-react-ssg.CjIppNIS.mjs';
import { d as deserializeState } from './shared/vite-react-ssg.C6pK7rvr.mjs';
import { M as META_CONTAINER_ID, c as convertRouteTreeToRouteOption } from './shared/vite-react-ssg.B-j07kW6.mjs';
export { r as registerPaths } from './shared/vite-react-ssg.B-j07kW6.mjs';
import 'react';
import 'react-dom';

const HAS_ADD_META_FLAG_KEY = "HAS_ADD_META_FLAG_KEY";
function Experimental_ViteReactSSG(routerOptions, fn, options = {}) {
  const {
    transformState,
    rootContainer = "#root",
    ssrWhenDev,
    getStyleCollector = null
  } = options;
  if (process.env.NODE_ENV === "development" && ssrWhenDev !== void 0)
    console.warn("[vite-react-ssg] `ssrWhenDev` option is no longer needed. If you want to use csr, just replace `vite-react-ssg dev` with `vite`.");
  const isClient = typeof window !== "undefined";
  const BASE_URL = routerOptions.basename ?? "/";
  const routeTree = routerOptions.routes;
  const OriginComponent = routeTree.options.component;
  if (!OriginComponent[HAS_ADD_META_FLAG_KEY]) {
    const component = () => /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx(OriginComponent, {}),
      /* @__PURE__ */ jsx("div", { id: META_CONTAINER_ID, style: { display: "none" }, children: /* @__PURE__ */ jsx(Meta, {}) })
    ] });
    component[HAS_ADD_META_FLAG_KEY] = true;
    routeTree.update({
      component
    });
  }
  async function createRoot(client = false, routePath) {
    const routes = await convertRouteTreeToRouteOption(
      routerOptions.routes,
      client,
      client ? (node) => {
        const isSSR = document.querySelector("[data-server-rendered=true]") !== null;
        if (!isSSR)
          return;
        node.options.loader = async (ctx) => {
          let pathname = ctx.location.pathname;
          if (process.env.NODE_ENV === "development") {
            const routeId = encodeURIComponent(node.id);
            const dataQuery = `_data=${routeId}`;
            const href = ctx.location.href;
            const url = href.includes("?") ? `${href}&${dataQuery}` : `${href}?${dataQuery}`;
            const res = await fetch(url);
            const header = res.headers;
            const contentType = header.get("content-type");
            if (contentType?.startsWith("application/json"))
              return res.json();
            return res.text();
          }
          let staticLoadData;
          if (window.__VITE_REACT_SSG_STATIC_LOADER_DATA__) {
            staticLoadData = window.__VITE_REACT_SSG_STATIC_LOADER_DATA__;
          } else {
            const manifestUrl = joinUrlSegments(BASE_URL, `static-loader-data-manifest-${window.__VITE_REACT_SSG_HASH__}.json`);
            staticLoadData = await (await fetch(withLeadingSlash(manifestUrl))).json();
            window.__VITE_REACT_SSG_STATIC_LOADER_DATA__ = staticLoadData;
          }
          if (BASE_URL !== "/") {
            pathname = stripBase(pathname, BASE_URL);
          }
          const routeData = staticLoadData?.[pathname]?.find((item) => item.id === node.id);
          return routeData?.loaderData ?? null;
        };
      } : void 0
    );
    const router = routerOptions.router;
    router.options.isServer = !client;
    const appRenderCallbacks = [];
    const onSSRAppRendered = client ? () => {
    } : (cb) => appRenderCallbacks.push(cb);
    const triggerOnSSRAppRendered = () => {
      return Promise.all(appRenderCallbacks.map((cb) => cb()));
    };
    const context = {
      isClient,
      routes,
      routeTree,
      router,
      routerOptions: {
        routes,
        basename: BASE_URL
      },
      onSSRAppRendered,
      triggerOnSSRAppRendered,
      initialState: {},
      transformState,
      routePath,
      base: BASE_URL,
      getStyleCollector,
      routerType: "tanstack"
    };
    if (client) {
      await documentReady();
      context.initialState = transformState?.(window.__INITIAL_STATE__ || {}) || deserializeState(window.__INITIAL_STATE__);
    }
    await fn?.(context);
    const initialState = context.initialState;
    return {
      ...context,
      initialState
    };
  }
  if (isClient) {
    (async () => {
      const container = typeof rootContainer === "string" ? document.querySelector(rootContainer) : rootContainer;
      if (!container) {
        if (typeof $jsdom === "undefined")
          console.warn("[vite-react-ssg] Root container not found.");
        return;
      }
      const context = await createRoot(true);
      window.__VITE_REACT_SSG_CONTEXT__ = context;
      const { router } = context;
      const isSSR = document.querySelector("[data-server-rendered=true]") !== null;
      if (!isSSR && process.env.NODE_ENV === "development") {
        render(
          /* @__PURE__ */ jsx(HelmetProvider, { children: /* @__PURE__ */ jsx(RouterProvider, { router }) }),
          container,
          options
        );
      } else {
        hydrate(
          /* @__PURE__ */ jsx(HelmetProvider, { children: /* @__PURE__ */ jsx(StartClient, { router }) }),
          container,
          options
        );
      }
    })();
  }
  return createRoot;
}

export { Experimental_ViteReactSSG };
