import { jsx } from 'react/jsx-runtime';
import { HelmetProvider } from 'react-helmet-async';
import { useLinkClickHandler, Link as Link$1, NavLink as NavLink$1, matchRoutes, createBrowserRouter, RouterProvider } from 'react-router-dom';
import { r as render, h as hydrate, d as documentReady } from './shared/vite-react-ssg.BxjO14Et.mjs';
export { C as ClientOnly, H as Head } from './shared/vite-react-ssg.BxjO14Et.mjs';
import { j as joinUrlSegments, w as withLeadingSlash, s as stripBase } from './shared/vite-react-ssg.CjIppNIS.mjs';
import { c as convertRoutesToDataRoutes } from './shared/vite-react-ssg.C0y5wbxl.mjs';
import { d as deserializeState } from './shared/vite-react-ssg.C6pK7rvr.mjs';
import React, { forwardRef } from 'react';
import 'react-dom';

const Link = forwardRef((props, ref) => {
  const {
    replace,
    state,
    target,
    preventScrollReset,
    relative,
    to,
    onClick
  } = props;
  const internalOnClick = useLinkClickHandler(to, {
    replace,
    state,
    target,
    preventScrollReset,
    relative
  });
  function handleClick(event) {
    if (onClick)
      onClick(event);
    if (!event.defaultPrevented) {
      React.startTransition(() => {
        internalOnClick(event);
      });
    }
    event.defaultPrevented = true;
    event.preventDefault();
  }
  return /* @__PURE__ */ jsx(Link$1, { ...props, ref, onClick: handleClick });
});
Link.displayName = "Link";
const NavLink = forwardRef((props, ref) => {
  const {
    replace,
    state,
    target,
    preventScrollReset,
    relative,
    to,
    onClick
  } = props;
  const internalOnClick = useLinkClickHandler(to, {
    replace,
    state,
    target,
    preventScrollReset,
    relative
  });
  function handleClick(event) {
    if (onClick)
      onClick(event);
    if (!event.defaultPrevented) {
      React.startTransition(() => {
        internalOnClick(event);
      });
    }
    event.defaultPrevented = true;
    event.preventDefault();
  }
  return /* @__PURE__ */ jsx(NavLink$1, { ...props, ref, onClick: handleClick });
});
NavLink.displayName = "NavLink";

function ViteReactSSG(routerOptions, fn, options = {}) {
  const {
    transformState,
    rootContainer = "#root",
    ssrWhenDev,
    getStyleCollector = null
  } = options;
  if (process.env.NODE_ENV === "development" && ssrWhenDev !== void 0)
    console.warn("[vite-react-ssg] `ssrWhenDev` option is no longer needed. If you want to use csr, just replace `vite-react-ssg dev` with `vite`.");
  const isClient = typeof window !== "undefined";
  const BASE_URL = routerOptions.basename ?? "/";
  const { v7_startTransition = true, ...routerFeature } = routerOptions.future ?? {};
  async function createRoot(client = false, routePath) {
    const browserRouter = client ? createBrowserRouter(
      convertRoutesToDataRoutes(routerOptions.routes, transformStaticLoaderRoute),
      { basename: BASE_URL, future: routerFeature }
    ) : void 0;
    const appRenderCallbacks = [];
    const onSSRAppRendered = client ? () => {
    } : (cb) => appRenderCallbacks.push(cb);
    const triggerOnSSRAppRendered = () => {
      return Promise.all(appRenderCallbacks.map((cb) => cb()));
    };
    const context = {
      isClient,
      routes: routerOptions.routes,
      router: browserRouter,
      routerOptions,
      onSSRAppRendered,
      triggerOnSSRAppRendered,
      initialState: {},
      transformState,
      routePath,
      base: BASE_URL,
      getStyleCollector,
      routerType: "remix"
    };
    if (client) {
      await documentReady();
      context.initialState = transformState?.(window.__INITIAL_STATE__ || {}) || deserializeState(window.__INITIAL_STATE__);
    }
    await fn?.(context);
    const initialState = context.initialState;
    return {
      ...context,
      initialState
    };
  }
  if (isClient) {
    (async () => {
      const container = typeof rootContainer === "string" ? document.querySelector(rootContainer) : rootContainer;
      if (!container) {
        if (typeof $jsdom === "undefined")
          console.warn("[vite-react-ssg] Root container not found.");
        return;
      }
      const lazeMatches = matchRoutes(routerOptions.routes, window.location, BASE_URL)?.filter(
        (m) => m.route.lazy
      );
      if (lazeMatches && lazeMatches?.length > 0) {
        await Promise.all(
          lazeMatches.map(async (m) => {
            const routeModule = await m.route.lazy();
            Object.assign(m.route, { ...routeModule, lazy: void 0 });
          })
        );
      }
      const context = await createRoot(true);
      window.__VITE_REACT_SSG_CONTEXT__ = context;
      const { router } = context;
      const app = /* @__PURE__ */ jsx(HelmetProvider, { children: /* @__PURE__ */ jsx(RouterProvider, { router, future: { v7_startTransition } }) });
      const isSSR = document.querySelector("[data-server-rendered=true]") !== null;
      if (!isSSR && process.env.NODE_ENV === "development") {
        render(app, container, options);
      } else {
        hydrate(app, container, options);
      }
    })();
  }
  return createRoot;
  function transformStaticLoaderRoute(route) {
    const isSSR = document.querySelector("[data-server-rendered=true]") !== null;
    if (!isSSR) {
      return route;
    }
    const loader = async ({ request }) => {
      if (process.env.NODE_ENV === "development") {
        const routeId = encodeURIComponent(route.id);
        const dataQuery = `_data=${routeId}`;
        const url = request.url.includes("?") ? `${request.url}&${dataQuery}` : `${request.url}?${dataQuery}`;
        return fetch(url);
      } else {
        let staticLoadData;
        if (window.__VITE_REACT_SSG_STATIC_LOADER_DATA__) {
          staticLoadData = window.__VITE_REACT_SSG_STATIC_LOADER_DATA__;
        } else {
          const manifestUrl = joinUrlSegments(BASE_URL, `static-loader-data-manifest-${window.__VITE_REACT_SSG_HASH__}.json`);
          staticLoadData = await (await fetch(withLeadingSlash(manifestUrl))).json();
          window.__VITE_REACT_SSG_STATIC_LOADER_DATA__ = staticLoadData;
        }
        const { url } = request;
        let { pathname } = new URL(url);
        if (BASE_URL !== "/") {
          pathname = stripBase(pathname, BASE_URL);
        }
        const routeData = staticLoadData?.[pathname]?.[route.id];
        return routeData ?? null;
      }
    };
    route.loader = loader;
    return route;
  }
}

export { Link, NavLink, ViteReactSSG };
