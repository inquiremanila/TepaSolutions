import { createRequire } from 'node:module';
import { join, parse, isAbsolute, dirname } from 'node:path';
import fs from 'fs-extra';
import { JSDOM } from 'jsdom';
import { gray, yellow, blue, dim, cyan, red, green, reset, bold, bgLightCyan } from 'kolorist';
import PQueue from 'p-queue';
import { resolveConfig, createLogger, build as build$1, mergeConfig, version as version$1, send, createServer } from 'vite';
import { a as withTrailingSlash, r as removeLeadingSlash, w as withLeadingSlash, s as stripBase, j as joinUrlSegments } from './vite-react-ssg.CjIppNIS.mjs';
import { s as serializeState } from './vite-react-ssg.C6pK7rvr.mjs';
import { jsx, Fragment } from 'react/jsx-runtime';
import { HelmetProvider } from 'react-helmet-async';
import { once } from 'node:events';
import { Readable, Writable } from 'node:stream';
import { c as convertRoutesToDataRoutes } from './vite-react-ssg.C0y5wbxl.mjs';
import * as ReactDomServer from 'react-dom/server';
import { M as META_CONTAINER_ID } from './vite-react-ssg.B-j07kW6.mjs';

const DYNAMIC_IMPORT_REGEX = /import\("([^)]+)"\)/g;
async function collectAssets({
  routes,
  locationArg,
  base,
  serverManifest,
  manifest,
  ssrManifest
}) {
  const { matchRoutes } = await import('react-router-dom');
  const matches = matchRoutes([...routes], locationArg, base);
  const routeEntries = matches?.map((item) => item.route.entry).filter(Boolean) ?? [];
  const dynamicImports = /* @__PURE__ */ new Set();
  matches?.forEach((item) => {
    let lazyStr = "";
    if (item.route.lazy) {
      lazyStr += item.route.lazy.toString();
    }
    if (item.route.Component?._payload?._result) {
      lazyStr += item.route.Component._payload._result.toString();
    }
    const match = lazyStr.matchAll(DYNAMIC_IMPORT_REGEX);
    for (const m of match) {
      dynamicImports.add(m[1].split("/").at(-1) ?? "");
    }
  });
  const entries = /* @__PURE__ */ new Set();
  routeEntries.forEach((e) => entries.add(e));
  const manifestEntries = [...Object.entries(serverManifest)];
  dynamicImports.forEach((name) => {
    const result = manifestEntries.find(([_, value]) => value.file.endsWith(name));
    if (result) {
      entries.add(result[0]);
    }
  });
  const modules = collectModulesForEntries(manifest, entries);
  const assets = /* @__PURE__ */ new Set();
  Array.from(modules).forEach((id) => {
    const files = ssrManifest[id] || [];
    files.forEach((file) => {
      assets.add(file);
    });
  });
  return assets;
}
function collectModulesForEntries(manifest, entries) {
  const mods = /* @__PURE__ */ new Set();
  if (!entries)
    return mods;
  for (const entry of entries)
    collectModules(manifest, entry, mods);
  return mods;
}
function collectModules(manifest, entry, mods = /* @__PURE__ */ new Set()) {
  if (!entry)
    return mods;
  mods.add(entry);
  manifest[entry]?.dynamicImports?.forEach((item) => {
    collectModules(manifest, item, mods);
  });
  return mods;
}

async function getBeastiesOrCritters(outDir, options = {}) {
  try {
    const BeastiesClass = (await import('beasties')).default;
    return new BeastiesClass({
      path: outDir,
      logLevel: "warn",
      external: true,
      inlineFonts: true,
      preloadFonts: true,
      ...options
    });
  } catch {
  }
  try {
    const CrittersClass = (await import('critters')).default;
    console.warn("`critters` is deprecated. Please use `beasties` instead.");
    return new CrittersClass({
      path: outDir,
      logLevel: "warn",
      external: true,
      inlineFonts: true,
      preloadFonts: true,
      ...options
    });
  } catch (e) {
    return void 0;
  }
}

const SCRIPT_COMMENT_PLACEHOLDER = "/* SCRIPT_COMMENT_PLACEHOLDER */";
async function renderHTML({
  rootContainerId,
  indexHTML,
  appHTML,
  metaAttributes,
  bodyAttributes,
  htmlAttributes,
  initialState
}) {
  const stateScript = "";
  const scriptPlaceHolder = `
<script>${SCRIPT_COMMENT_PLACEHOLDER}<\/script>`;
  const headStartTag = "<head>";
  const metaTags = metaAttributes.join("");
  indexHTML = indexHTML.replace(headStartTag, headStartTag + metaTags);
  const bodyStartTag = "<body";
  indexHTML = indexHTML.replace(bodyStartTag, `${bodyStartTag} ${bodyAttributes}`);
  const htmlStartTag = "<html";
  indexHTML = indexHTML.replace(htmlStartTag, `${htmlStartTag} ${htmlAttributes}`);
  const container = `<div id="${rootContainerId}"></div>`;
  if (indexHTML.includes(container)) {
    return indexHTML.replace(
      container,
      `<div id="${rootContainerId}" data-server-rendered="true">${appHTML}</div>${stateScript}${scriptPlaceHolder}`
    );
  }
  const html5Parser = await import('html5parser');
  const ast = html5Parser.parse(indexHTML);
  let renderedOutput;
  html5Parser.walk(ast, {
    enter: (node) => {
      if (!renderedOutput && node?.type === html5Parser.SyntaxKind.Tag && Array.isArray(node.attributes) && node.attributes.length > 0 && node.attributes.some((attr) => attr.name.value === "id" && attr.value?.value === rootContainerId)) {
        const attributesStringified = [...node.attributes.map(({ name: { value: name }, value }) => `${name}="${value.value}"`)].join(" ");
        const indexHTMLBefore = indexHTML.slice(0, node.start);
        const indexHTMLAfter = indexHTML.slice(node.end);
        renderedOutput = `${indexHTMLBefore}<${node.name} ${attributesStringified} data-server-rendered="true">${appHTML}</${node.name}>${stateScript}${scriptPlaceHolder}${indexHTMLAfter}`;
      }
    }
  });
  if (!renderedOutput)
    throw new Error(`Could not find a tag with id="${rootContainerId}" to replace it with server-side rendered HTML`);
  return renderedOutput;
}
async function detectEntry(root, htmlEntry = "index.html") {
  const scriptSrcReg = /<script(?:.*?)src=["'](.+?)["'](?!<)(?:.*)\>(?:[\n\r\s]*?)(?:<\/script>)/gim;
  const html = await fs.readFile(join(root, htmlEntry), "utf-8");
  const scripts = [...html.matchAll(scriptSrcReg)];
  const [, entry] = scripts.find((matchResult) => {
    const [script] = matchResult;
    const [, scriptType] = script.match(/.*\stype=(?:'|")?([^>'"\s]+)/i) || [];
    return scriptType === "module";
  }) || [];
  return entry || "src/main.ts";
}
function createLink$1(href) {
  return `<link rel="stylesheet" href="${href}">`;
}

function renderPreloadLinks(document, assets) {
  const seen = /* @__PURE__ */ new Set();
  if (assets) {
    assets.forEach((file) => {
      if (!seen.has(file)) {
        seen.add(file);
        renderPreloadLink(document, file);
      }
    });
  }
}
function renderPreloadLink(document, file) {
  if (file.endsWith(".js")) {
    appendLink(document, {
      rel: "modulepreload",
      crossOrigin: "",
      href: file
    });
  } else if (file.endsWith(".css")) {
    appendLink(document, {
      rel: "stylesheet",
      href: file,
      crossOrigin: ""
    });
  } else if (file.endsWith(".woff") || file.endsWith(".woff2") || file.endsWith(".ttf")) {
    appendLink(document, {
      rel: "preload",
      as: "font",
      type: "font/woff2",
      href: file,
      crossOrigin: ""
    });
  } else if (file.endsWith(".png") || file.endsWith(".jpg") || file.endsWith(".jpeg") || file.endsWith(".webp") || file.endsWith(".gif") || file.endsWith(".ico") || file.endsWith(".svg")) {
    appendLink(document, {
      rel: "preload",
      as: "image",
      href: file,
      crossOrigin: ""
    });
  }
}
function createLink(document) {
  return document.createElement("link");
}
function setAttrs(el, attrs) {
  const keys = Object.keys(attrs);
  for (const key of keys)
    el.setAttribute(key, attrs[key]);
}
function appendLink(document, attrs) {
  const exits = document.head.querySelector(`link[href='${attrs.file}']`);
  if (exits)
    return;
  const link = createLink(document);
  setAttrs(link, attrs);
  document.head.appendChild(link);
}

function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    console.error(
      "The following error is a bug in Vite-react-ssg; please open an issue! https://github.com/Daydreamer-riri/vite-react-ssg/issues/new"
    );
    throw new Error(message);
  }
}

function fromNodeHeaders(nodeHeaders) {
  const headers = new Headers();
  for (const [key, values] of Object.entries(nodeHeaders)) {
    if (values) {
      if (Array.isArray(values)) {
        for (const value of values)
          headers.append(key, value);
      } else {
        headers.set(key, values);
      }
    }
  }
  return headers;
}
function fromNodeRequest(nodeReq) {
  const origin = nodeReq.headers.origin && nodeReq.headers.origin !== "null" ? nodeReq.headers.origin : `http://${nodeReq.headers.host}`;
  invariant(
    nodeReq.originalUrl,
    "Expected `nodeReq.originalUrl` to be defined"
  );
  const url = new URL(nodeReq.originalUrl, origin);
  const init = {
    method: nodeReq.method,
    headers: fromNodeHeaders(nodeReq.headers)
  };
  return new Request(url.href, init);
}
async function toNodeRequest(res, nodeRes) {
  nodeRes.statusCode = res.status;
  nodeRes.statusMessage = res.statusText;
  for (const [name, value] of res.headers) {
    nodeRes.setHeader(name, value);
  }
  if (res.body) {
    const responseBody = res.body;
    const readable = Readable.from(responseBody);
    readable.pipe(nodeRes);
    await once(readable, "end");
  } else {
    nodeRes.end();
  }
}
function json(data, init) {
  if (init === void 0) {
    init = {};
  }
  const responseInit = typeof init === "number" ? {
    status: init
  } : init;
  const headers = new Headers(responseInit.headers);
  if (!headers.has("Content-Type")) {
    headers.set("Content-Type", "application/json; charset=utf-8");
  }
  return new Response(JSON.stringify(data), {
    ...responseInit,
    headers
  });
}
function stripDataParam(request) {
  const url = new URL(request.url);
  url.searchParams.delete("_data");
  const init = {
    method: request.method,
    body: request.body,
    headers: request.headers,
    signal: request.signal
  };
  if (init.body) {
    init.duplex = "half";
  }
  return new Request(url.href, init);
}

async function renderStaticApp(app) {
  if (!ReactDomServer.renderToPipeableStream) {
    return ReactDomServer.renderToString(/* @__PURE__ */ jsx(Fragment, { children: app }));
  }
  const writableStream = new WritableAsPromise();
  const { pipe } = ReactDomServer.renderToPipeableStream(app, {
    onError(error) {
      writableStream.destroy(error);
    },
    onAllReady() {
      pipe(writableStream);
    }
  });
  return writableStream.getPromise();
}
class WritableAsPromise extends Writable {
  _output;
  _deferred;
  constructor() {
    super();
    this._output = "";
    this._deferred = {
      promise: null,
      resolve: () => null,
      reject: () => null
    };
    this._deferred.promise = new Promise((resolve, reject) => {
      this._deferred.resolve = resolve;
      this._deferred.reject = reject;
    });
  }
  _write(chunk, _enc, next) {
    this._output += chunk.toString();
    next();
  }
  _destroy(error, next) {
    if (error instanceof Error)
      this._deferred.reject(error);
    else
      next();
  }
  end() {
    this._deferred.resolve(this._output);
    return this.destroy();
  }
  getPromise() {
    return this._deferred.promise;
  }
}

const version = "0.8.9";

function buildLog(text, count) {
  console.log(`
${gray("[vite-react-ssg]")} ${yellow(text)}${count ? blue(` (${count})`) : ""}`);
}
function getSize(str) {
  return `${(str.length / 1024).toFixed(2)} KiB`;
}
async function routesToPaths(routes) {
  if (!routes || routes.length === 0)
    return { paths: ["/"] };
  const paths = /* @__PURE__ */ new Set();
  const getPaths = async (routes2, prefix = "") => {
    prefix = prefix.replace(/\/$/g, "");
    for (let route of routes2) {
      if (route.lazy) {
        const lazyData = await route.lazy();
        if (lazyData) {
          route = {
            ...route,
            ...lazyData
          };
        }
      }
      let path = route.path;
      path = handlePath(path, prefix);
      if (route.getStaticPaths && isDynamicSegmentsRoute(path)) {
        const staticPaths = await route.getStaticPaths();
        for (let staticPath of staticPaths) {
          staticPath = handlePath(staticPath, prefix);
          if (Array.isArray(route.children))
            await getPaths(route.children, staticPath);
        }
      }
      if (route.index && !path) {
        paths.add("/");
      }
      if (Array.isArray(route.children))
        await getPaths(route.children, path);
    }
  };
  await getPaths(routes);
  return { paths: Array.from(paths) };
  function handlePath(path, prefix) {
    if (path != null) {
      path = prefix && !path.startsWith("/") ? `${prefix}${path ? `/${path}` : ""}` : path;
      paths.add(path);
    }
    return path;
  }
}
async function resolveAlias(config, entry) {
  const resolver = config.createResolver();
  const result = await resolver(entry, config.root);
  return result || join(config.root, entry);
}
function createRequest(path) {
  const url = new URL(path, "http://vite-react-ssg.com");
  url.search = "";
  url.hash = "";
  url.pathname = path;
  return new Request(url.href);
}
const dynamicRE = /[:*?]/;
function isDynamicSegmentsRoute(route) {
  if (!route)
    return false;
  return dynamicRE.test(route);
}

function extractHelmet(html, context, styleCollector) {
  const { helmet } = context;
  const htmlAttributes = helmet.htmlAttributes.toString();
  const bodyAttributes = helmet.bodyAttributes.toString();
  let titleString = helmet.title.toString();
  if (titleString.split(">")[1] === "</title") {
    titleString = "";
  }
  const metaStrings = [
    titleString,
    helmet.meta.toString(),
    helmet.link.toString(),
    helmet.script.toString()
  ];
  const styleTag = styleCollector?.toString?.(html) ?? "";
  const metaAttributes = metaStrings.filter(Boolean);
  return { htmlAttributes, bodyAttributes, metaAttributes, styleTag };
}

class RemixAdapter {
  context;
  constructor(context) {
    this.context = context;
  }
  async render(path) {
    const { base, routes, getStyleCollector, routerOptions } = this.context;
    const fetchUrl = `${withTrailingSlash(base)}${removeLeadingSlash(path)}`;
    const request = createRequest(fetchUrl);
    const styleCollector = getStyleCollector ? await getStyleCollector() : null;
    const helmetContext = {};
    let routerContext = null;
    const { StaticRouterProvider, createStaticHandler, createStaticRouter } = await import('react-router-dom/server.js');
    const { dataRoutes, query } = createStaticHandler([...routes], { basename: base });
    const _context = await query(request);
    if (_context instanceof Response)
      throw _context;
    routerContext = _context;
    const router = createStaticRouter(dataRoutes, routerContext, { future: routerOptions.future });
    let app = /* @__PURE__ */ jsx(HelmetProvider, { context: helmetContext, children: /* @__PURE__ */ jsx(StaticRouterProvider, { router, context: routerContext }) });
    if (styleCollector)
      app = styleCollector.collect(app);
    const appHTML = await renderStaticApp(app);
    const { htmlAttributes, bodyAttributes, metaAttributes, styleTag } = extractHelmet(appHTML, helmetContext, styleCollector);
    return { appHTML, htmlAttributes, bodyAttributes, metaAttributes, styleTag, routerContext };
  }
  handleLoader = async (req, res) => {
    const { routes, base } = this.context;
    const { matchRoutes } = await import('react-router-dom');
    const request = fromNodeRequest(req);
    const url = new URL(request.url);
    const routeId = decodeURIComponent(url.searchParams.get("_data"));
    const matches = matchRoutes(
      convertRoutesToDataRoutes([...routes], (route) => route),
      {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash,
        state: null,
        key: "default"
      },
      base
    );
    if (!matches) {
      res.statusCode = 404;
      res.end(`Route not found: ${routeId}`);
      return;
    }
    const match = matches.find((m) => m.route.id === routeId);
    if (!match) {
      res.statusCode = 404;
      res.end(`Route not found: ${routeId}`);
      return;
    }
    const loader = match.route.loader ?? await match.route.lazy?.().then((m) => m.loader);
    if (!loader) {
      res.statusCode = 200;
      res.end(`There is no loader for the route: ${routeId}`);
      return;
    }
    const response = await callRouteLoader({
      loader,
      params: match.params,
      request,
      routeId
    });
    await toNodeRequest(response, res);
  };
}
async function callRouteLoader({
  // loadContext,
  loader,
  params,
  request,
  routeId
}) {
  const { json } = await import('react-router-dom');
  const result = await loader({
    request: stripDataParam(stripIndexParam(request)),
    params
  });
  if (result === void 0) {
    throw new Error(
      `You defined a loader for route "${routeId}" but didn't return anything from your \`loader\` function. Please return a value or \`null\`.`
    );
  }
  return isResponse(result) ? result : json(result);
}
function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
function stripIndexParam(request) {
  const url = new URL(request.url);
  const indexValues = url.searchParams.getAll("index");
  url.searchParams.delete("index");
  const indexValuesToKeep = [];
  for (const indexValue of indexValues) {
    if (indexValue) {
      indexValuesToKeep.push(indexValue);
    }
  }
  for (const toKeep of indexValuesToKeep) {
    url.searchParams.append("index", toKeep);
  }
  const init = {
    method: request.method,
    body: request.body,
    headers: request.headers,
    signal: request.signal
  };
  if (init.body) {
    init.duplex = "half";
  }
  return new Request(url.href, init);
}

class SinglePageAdapter {
  context;
  constructor(context) {
    this.context = context;
  }
  render = async () => {
    const { app: inner, getStyleCollector } = this.context;
    const helmetContext = {};
    const styleCollector = getStyleCollector ? await getStyleCollector() : null;
    let app = /* @__PURE__ */ jsx(HelmetProvider, { context: helmetContext, children: inner });
    if (styleCollector)
      app = styleCollector.collect(app);
    const appHTML = await renderStaticApp(app);
    const { htmlAttributes, bodyAttributes, metaAttributes, styleTag } = extractHelmet(appHTML, helmetContext, styleCollector);
    return { appHTML, htmlAttributes, bodyAttributes, metaAttributes, styleTag, routerContext: { loaderData: {} } };
  };
  handleLoader = () => {
  };
}

class TanstackAdapter {
  context;
  constructor(context) {
    this.context = context;
  }
  render = async (path) => {
    const { getStyleCollector, router: _router, base } = this.context;
    const styleCollector = getStyleCollector ? await getStyleCollector() : null;
    path = `${withTrailingSlash(base)}${removeLeadingSlash(path)}`;
    const { createRouter, createMemoryHistory } = await import('@tanstack/react-router');
    const router = createRouter(_router.options);
    const { StartServer } = await import('@tanstack/start/server');
    const memoryHistory = createMemoryHistory({
      initialEntries: [path]
    });
    router.update({
      history: memoryHistory
    });
    await router.load();
    const helmetContext = {};
    let app = /* @__PURE__ */ jsx(HelmetProvider, { context: helmetContext, children: /* @__PURE__ */ jsx(StartServer, { router }) });
    const matchRoutes = router.matchRoutes(router.latestLocation);
    const routerContext = {
      loaderData: matchRoutes.map((item) => ({ id: item.routeId, loaderData: item.loaderData }))
    };
    if (styleCollector)
      app = styleCollector.collect(app);
    const appHTML = await renderStaticApp(app);
    const jsdom = new JSDOM(appHTML);
    const headElements = jsdom.window.document.querySelector(`#${META_CONTAINER_ID}`);
    const { htmlAttributes, bodyAttributes, metaAttributes, styleTag } = extractHelmet(appHTML, helmetContext, styleCollector);
    if (headElements?.innerHTML) {
      metaAttributes.unshift(headElements.innerHTML);
      headElements.innerHTML = "";
    }
    return {
      appHTML: jsdom.window.document.body.innerHTML,
      htmlAttributes,
      bodyAttributes,
      metaAttributes,
      styleTag,
      routerContext
    };
  };
  handleLoader = async (req, res) => {
    const request = fromNodeRequest(req);
    const url = new URL(request.url);
    const routeId = decodeURIComponent(url.searchParams.get("_data"));
    const { router } = this.context;
    const matches = router.matchRoutes(url.pathname, Object.fromEntries(url.searchParams.entries()));
    const _match = matches.find((m) => m.routeId === routeId);
    const matchRoute = router.flatRoutes.find((item) => {
      const matchRouteId = _match?.routeId === "__root__" ? "/" : _match?.routeId;
      return item.id === matchRouteId;
    });
    if (!matchRoute) {
      res.statusCode = 404;
      res.end(`Route not found: ${routeId}`);
      return;
    }
    const getLoaderContext = () => {
      const {
        params,
        loaderDeps,
        abortController,
        context,
        cause,
        index
      } = _match;
      const search = router.options.parseSearch(url.search);
      const searchStr = router.options.stringifySearch(search);
      return {
        preload: false,
        navigate: async () => {
        },
        params,
        deps: loaderDeps,
        abortController,
        context,
        location: {
          ...url,
          search,
          searchStr,
          state: { __TSR_index: index }
        },
        cause,
        route: matchRoute,
        parentMatchPromise: null
      };
    };
    const loaderData = await matchRoute.options.loader?.(getLoaderContext());
    if (!loaderData) {
      res.statusCode = 200;
      res.end(`There is no loader for the route: ${routeId}`);
      return;
    }
    await toNodeRequest(json(loaderData), res);
  };
}

function getAdapter(context) {
  switch (context.routerType) {
    case "remix":
      return new RemixAdapter(context);
    case "tanstack":
      return new TanstackAdapter(context);
    case "single-page":
      return new SinglePageAdapter(context);
  }
}

const dotVitedir = Number.parseInt(version$1) >= 5 ? [".vite"] : [];
function DefaultIncludedRoutes(paths, _routes) {
  return paths.filter((i) => !i.includes(":") && !i.includes("*"));
}
async function build(ssgOptions = {}, viteConfig = {}) {
  const mode = process.env.MODE || process.env.NODE_ENV || ssgOptions.mode || "production";
  const config = await resolveConfig(viteConfig, "build", mode, mode);
  const cwd = process.cwd();
  const root = config.root || cwd;
  const hash = Math.random().toString(36).substring(2, 12);
  const ssgOut = join(root, ".vite-react-ssg-temp", hash);
  let outDir = config.build.outDir || "dist";
  const configBase = config.base;
  const mergedOptions = Object.assign({}, config.ssgOptions || {}, ssgOptions);
  const {
    script = "sync",
    mock = false,
    htmlEntry = "index.html",
    entry = await detectEntry(root, htmlEntry),
    formatting = "none",
    includedRoutes: configIncludedRoutes = DefaultIncludedRoutes,
    onBeforePageRender,
    onPageRendered,
    onFinished,
    dirStyle = "flat",
    includeAllRoutes = false,
    format = "esm",
    concurrency = 20,
    rootContainerId = "root"
  } = mergedOptions;
  const beastiesOptions = mergedOptions.beastiesOptions ?? mergedOptions.crittersOptions ?? {};
  if (fs.existsSync(ssgOut))
    await fs.remove(ssgOut);
  const clientLogger = createLogger();
  const loggerWarn = clientLogger.warn;
  clientLogger.warn = (msg, options) => {
    if (msg.includes("vite:resolve") && msg.includes("externalized for browser compatibility"))
      return;
    loggerWarn(msg, options);
  };
  buildLog("Build for client...");
  await build$1(mergeConfig(viteConfig, {
    build: {
      manifest: true,
      ssrManifest: true,
      rollupOptions: {
        input: {
          app: join(root, htmlEntry || "./index.html")
        },
        // @ts-expect-error rollup type
        onLog(level, log, handler) {
          if (log.message.includes("react-helmet-async"))
            return;
          handler(level, log);
        }
      }
    },
    customLogger: clientLogger,
    mode: config.mode,
    plugins: [{
      name: "vite-react-ssg:get-oup-dir",
      configResolved(resolvedConfig) {
        outDir = resolvedConfig.build.outDir || "dist";
      }
    }]
  }));
  let unmock = () => {
  };
  if (mock) {
    const { jsdomGlobal } = await import('../chunks/jsdomGlobal.mjs');
    unmock = jsdomGlobal();
  }
  buildLog("Build for server...");
  process.env.VITE_SSG = "true";
  const ssrEntry = await resolveAlias(config, entry);
  await build$1(mergeConfig(viteConfig, {
    build: {
      ssr: ssrEntry,
      manifest: true,
      outDir: ssgOut,
      minify: false,
      cssCodeSplit: false,
      rollupOptions: {
        output: format === "esm" ? {
          entryFileNames: "[name].mjs",
          format: "esm"
        } : {
          entryFileNames: "[name].cjs",
          format: "cjs"
        },
        // @ts-expect-error rollup type
        onLog(level, log, handler) {
          if (log.message.includes("react-helmet-async"))
            return;
          handler(level, log);
        }
      }
    },
    mode: config.mode
  }));
  const prefix = format === "esm" && process.platform === "win32" ? "file://" : "";
  const ext = format === "esm" ? ".mjs" : ".cjs";
  const serverEntry = prefix + join(ssgOut, parse(ssrEntry).name + ext).replace(/\\/g, "/");
  const serverManifest = JSON.parse(await fs.readFile(join(ssgOut, ...dotVitedir, "manifest.json"), "utf-8"));
  const _require = createRequire(import.meta.url);
  const { createRoot, includedRoutes: serverEntryIncludedRoutes } = format === "esm" ? await import(serverEntry) : _require(serverEntry);
  const includedRoutes = serverEntryIncludedRoutes || configIncludedRoutes;
  const { routes } = await createRoot(false);
  const { paths } = await routesToPaths(routes);
  let routesPaths = includeAllRoutes ? paths : await includedRoutes(paths, routes || []);
  routesPaths = DefaultIncludedRoutes(routesPaths);
  routesPaths = Array.from(new Set(routesPaths));
  buildLog("Rendering Pages...", routesPaths.length);
  const beasties = beastiesOptions !== false ? await getBeastiesOrCritters(outDir, { publicPath: configBase, ...beastiesOptions }) : void 0;
  if (beasties)
    console.log(`${gray("[vite-react-ssg]")} ${blue("Critical CSS generation enabled via `beasties`")}`);
  const out = isAbsolute(outDir) ? outDir : join(root, outDir);
  const ssrManifest = JSON.parse(await fs.readFile(join(out, ...dotVitedir, "ssr-manifest.json"), "utf-8"));
  const manifest = JSON.parse(await fs.readFile(join(out, ...dotVitedir, "manifest.json"), "utf-8"));
  let indexHTML = await fs.readFile(join(out, htmlEntry), "utf-8");
  fs.rmSync(join(out, htmlEntry));
  indexHTML = rewriteScripts(indexHTML, script);
  const queue = new PQueue({ concurrency });
  const crittersQueue = new PQueue({ concurrency: 1 });
  const staticLoaderDataManifest = {};
  for (const path of routesPaths) {
    queue.add(async () => {
      try {
        const appCtx = await createRoot(false, path);
        const { base, routes: routes2, triggerOnSSRAppRendered, transformState = serializeState, app, routerType } = appCtx;
        const transformedIndexHTML = await onBeforePageRender?.(path, indexHTML, appCtx) || indexHTML;
        const fetchUrl = `${withTrailingSlash(base)}${removeLeadingSlash(path)}`;
        const adapter = getAdapter(appCtx);
        const assets = !app && routerType === "remix" ? await collectAssets({ routes: [...routes2], locationArg: fetchUrl, base, serverManifest, manifest, ssrManifest }) : /* @__PURE__ */ new Set();
        const { appHTML, bodyAttributes, htmlAttributes, metaAttributes, styleTag, routerContext } = await adapter.render(path);
        staticLoaderDataManifest[withLeadingSlash(path)] = routerContext?.loaderData;
        await triggerOnSSRAppRendered?.(path, appHTML, appCtx);
        const renderedHTML = await renderHTML({
          rootContainerId,
          appHTML,
          indexHTML: transformedIndexHTML,
          metaAttributes,
          bodyAttributes,
          htmlAttributes,
          initialState: null
        });
        const jsdom = new JSDOM(renderedHTML);
        renderPreloadLinks(jsdom.window.document, assets);
        const html = jsdom.serialize();
        let transformed = await onPageRendered?.(path, html, appCtx) || html;
        transformed = transformed.replace(SCRIPT_COMMENT_PLACEHOLDER, `window.__VITE_REACT_SSG_HASH__ = '${hash}'`);
        if (beasties) {
          transformed = await crittersQueue.add(() => beasties.process(transformed));
          transformed = transformed.replace(/<link\srel="stylesheet"/g, '<link rel="stylesheet" crossorigin');
        }
        if (styleTag)
          transformed = transformed.replace("<head>", `<head>${styleTag}`);
        const formatted = await formatHtml(transformed, formatting);
        const relativeRouteFile = `${(path.endsWith("/") ? `${path}index` : path).replace(/^\//g, "")}.html`;
        const filename = dirStyle === "nested" ? join(path.replace(/^\//g, ""), "index.html") : relativeRouteFile;
        await fs.ensureDir(join(out, dirname(filename)));
        await fs.writeFile(join(out, filename), formatted, "utf-8");
        config.logger.info(
          `${dim(`${outDir}/`)}${cyan(filename.padEnd(15, " "))}  ${dim(getSize(formatted))}`
        );
      } catch (err) {
        throw new Error(`${gray("[vite-react-ssg]")} ${red(`Error on page: ${cyan(path)}`)}
${err.stack}`);
      }
    });
  }
  await queue.start().onIdle();
  buildLog("Generating static loader data manifest...");
  const staticLoaderDataManifestString = JSON.stringify(staticLoaderDataManifest, null, 0);
  await fs.writeFile(join(out, `static-loader-data-manifest-${hash}.json`), staticLoaderDataManifestString);
  config.logger.info(
    `${dim(`${outDir}/`)}${cyan(`static-loader-data-manifest-${hash}.json`.padEnd(15, " "))}  ${dim(getSize(staticLoaderDataManifestString))}`
  );
  await fs.remove(join(root, ".vite-react-ssg-temp"));
  unmock();
  const pwaPlugin = config.plugins.find((i) => i.name === "vite-plugin-pwa")?.api;
  if (pwaPlugin && !pwaPlugin.disabled && pwaPlugin.generateSW) {
    buildLog("Regenerate PWA...");
    await pwaPlugin.generateSW();
  }
  console.log(`
${gray("[vite-react-ssg]")} ${green("Build finished.")}`);
  await onFinished?.();
  const waitInSeconds = 15;
  const timeout = setTimeout(() => {
    console.log(`${gray("[vite-react-ssg]")} ${yellow(`Build process still running after ${waitInSeconds}s`)}.  There might be something misconfigured in your setup. Force exit.`);
    process.exit(0);
  }, waitInSeconds * 1e3);
  timeout.unref();
}
function rewriteScripts(indexHTML, mode) {
  if (!mode || mode === "sync")
    return indexHTML;
  return indexHTML.replace(/<script type="module" /g, `<script type="module" ${mode} `);
}
async function formatHtml(html, formatting) {
  if (formatting === "prettify") {
    try {
      const prettier = (await import('prettier/esm/standalone.mjs')).default;
      const parserHTML = (await import('prettier/esm/parser-html.mjs')).default;
      return prettier.format(html, { semi: false, parser: "html", plugins: [parserHTML] });
    } catch (e) {
      console.error(`${gray("[vite-react-ssg]")} ${red(`Error formatting html: ${e?.message}`)}`);
      return html;
    }
  }
  return html;
}

function ssrServerPlugin({
  template,
  ssrEntry,
  onBeforePageRender,
  entry,
  rootContainerId,
  onPageRendered
}) {
  return {
    name: "vite-react-ssg:dev-server",
    configureServer(server) {
      const renderMiddleware = async (req, res, next) => {
        try {
          const url = req.originalUrl;
          const createRoot = await server.ssrLoadModule(ssrEntry).then((m) => m.createRoot);
          const appCtx = await createRoot(false, url);
          const adapter = getAdapter(appCtx);
          const { app, base } = appCtx;
          const [pathname, search] = url.split("?");
          const searchParams = new URLSearchParams(search);
          if (!app && searchParams.has("_data")) {
            return adapter.handleLoader(req, res);
          }
          const indexHTML = await server.transformIndexHtml(url, template);
          const transformedIndexHTML = await onBeforePageRender?.(url, indexHTML, appCtx) || indexHTML;
          const { appHTML, bodyAttributes, htmlAttributes, metaAttributes, styleTag } = await adapter.render(stripBase(pathname, base));
          metaAttributes.push(styleTag);
          const mods = await Promise.all(
            [ssrEntry, entry].map(async (entry2) => await server.moduleGraph.getModuleByUrl(entry2))
          );
          const assetsUrls = /* @__PURE__ */ new Set();
          const collectedMods = /* @__PURE__ */ new Set();
          const collectAssets = async (mod) => {
            if (!mod || !mod?.ssrTransformResult || collectedMods.has(mod))
              return;
            collectedMods.add(mod);
            const { deps = [], dynamicDeps = [] } = mod?.ssrTransformResult;
            const allDeps = [...deps, ...dynamicDeps];
            for (const dep of allDeps) {
              if (dep.endsWith(".css") || dep.endsWith(".scss") || dep.endsWith(".sass") || dep.endsWith(".less")) {
                assetsUrls.add(dep);
              } else if (dep.endsWith(".ts") || dep.endsWith(".tsx")) {
                const depModule = await server.moduleGraph.getModuleByUrl(dep);
                depModule && await collectAssets(depModule);
              }
            }
          };
          await Promise.all(mods.map(async (mod) => collectAssets(mod)));
          const preloadLink = [...assetsUrls].map((item) => createLink$1(joinUrlSegments(server.config.base, item)));
          metaAttributes.push(...preloadLink);
          const renderedHTML = await renderHTML({
            rootContainerId,
            appHTML,
            indexHTML: transformedIndexHTML,
            metaAttributes,
            bodyAttributes,
            htmlAttributes,
            initialState: null
          });
          const transformed = await onPageRendered?.(url, renderedHTML, appCtx) || renderedHTML;
          res.statusCode = 200;
          res.setHeader("Content-Type", "text/html");
          const isDev = "pluginContainer" in server;
          const headers = isDev ? server.config.server.headers : server.config.preview.headers;
          send(req, res, transformed, "html", { headers });
        } catch (e) {
          server.ssrFixStacktrace(e);
          console.error(`[vite-react-ssg] error: ${e.stack}`);
          res.statusCode = 500;
          res.end(e.stack);
        }
      };
      return () => {
        server.middlewares.use(renderMiddleware);
      };
    }
  };
}

async function dev(ssgOptions = {}, viteConfig = {}, customOptions) {
  const mode = process.env.MODE || process.env.NODE_ENV || ssgOptions.mode || "development";
  const config = await resolveConfig(viteConfig, "serve", mode, mode);
  const cwd = process.cwd();
  const root = config.root || cwd;
  const {
    htmlEntry = "index.html",
    entry = await detectEntry(root, htmlEntry),
    onBeforePageRender,
    onPageRendered,
    rootContainerId = "root",
    mock = false
  } = Object.assign({}, config.ssgOptions || {}, ssgOptions);
  const ssrEntry = await resolveAlias(config, entry);
  const template = await fs.readFile(join(root, htmlEntry), "utf-8");
  let viteServer;
  globalThis.__ssr_start_time = performance.now();
  createServer$1().catch((err) => {
    console.error(
      `${red(`failed to start server. error:`)}
${err.stack}`
    );
    process.exit(1);
  });
  async function createServer$1() {
    process.env.__DEV_MODE_SSR = "true";
    if (mock) {
      const { jsdomGlobal } = await import('../chunks/jsdomGlobal.mjs');
      jsdomGlobal();
    }
    viteServer = await createServer(
      mergeConfig(
        {
          ...viteConfig,
          plugins: [
            ...viteConfig.plugins ?? [],
            ssrServerPlugin({
              template,
              ssrEntry,
              onBeforePageRender,
              onPageRendered,
              entry,
              rootContainerId
            })
          ]
        },
        {}
      )
    );
    await viteServer.listen();
    printServerInfo(viteServer, !!customOptions);
    viteServer.bindCLIShortcuts({ print: true });
    return viteServer;
  }
}
async function printServerInfo(server, onlyUrl = false) {
  if (onlyUrl)
    return server.printUrls();
  const info = server.config.logger.info;
  let ssrReadyMessage = " -- SSR";
  if (globalThis.__ssr_start_time) {
    ssrReadyMessage += ` ready in ${reset(bold(`${Math.round(
      // @ts-expect-error global var
      performance.now() - globalThis.__ssr_start_time
    )}ms`))}`;
  }
  info(
    `
 ${bgLightCyan(` VITE-REACT-SSG v${version} `)}`,
    { clear: !server.config.logger.hasWarned }
  );
  info(
    `${cyan(`
  VITE v${version$1}`) + dim(ssrReadyMessage)}
`
  );
  info(
    green("  dev server running at:")
  );
  server.printUrls();
}

export { build as b, dev as d };
